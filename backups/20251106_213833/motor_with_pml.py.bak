import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'src'))

import pandas as pd
import numpy as np
import logging
from typing import Dict, List, Optional
from datetime import datetime
import time

from core.portfolio_manager import PortfolioManagerLayer
from core.strategy_adapter import StrategyAdapter
from core.signal_schema import InstitutionalSignal

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ============================================================================
# CONFIGURACIÓN DE CAPITAL Y FAMILIAS
# ============================================================================

TOTAL_CAPITAL = 100000.0  # Capital total del portfolio

FAMILY_ALLOCATIONS = {
    'momentum': 0.35,      # 35% para estrategias momentum
    'mean_reversion': 0.25,  # 25% para mean reversion
    'breakout': 0.20,      # 20% para breakouts
    'other': 0.15          # 15% para otras estrategias
}

STRATEGY_FAMILIES = {
    'momentum_quality': 'momentum',
    # Agregar más estrategias aquí según se agreguen
}


class ExampleMomentumStrategy(StrategyAdapter):
    """Estrategia de momentum de ejemplo."""
    
    def __init__(self, bus=None):
        super().__init__(
            strategy_id='momentum_quality',
            strategy_version='1.0.0'
        )
        self._bus = bus
    
    def evaluate(self, data: pd.DataFrame, features: Dict,
                 instrument: str, horizon: str) -> Optional[InstitutionalSignal]:
        """Evalúa setup de momentum."""
        
        if len(data) < 20:
            return None
        
        close = data['close']
        sma_20 = close.rolling(window=20).mean().iloc[-1]
        current_price = close.iloc[-1]
        
        ofi = features.get('ofi', 0.0)
        
        if ofi > 0.5 and current_price > sma_20:
            direction = 1
            confidence = min(abs(ofi), 0.95)
        elif ofi < -0.5 and current_price < sma_20:
            direction = -1
            confidence = min(abs(ofi), 0.95)
        else:
            return None
        
        rolling_range = data['high'].rolling(20).max() - data['low'].rolling(20).min()
        range_value = rolling_range.iloc[-1] / 20
        stop_distance = 1.5 * range_value
        
        target_profile = {
            'primary': 2.0,
            'extended': 3.0
        }
        
        regime_sensitivity = {
            'trend': 0.8,
            'range': 0.3,
            'shock': 0.2
        }
        
        quality_metrics = {
            'hit_rate': 0.58,
            'sharpe': 1.8,
            'max_drawdown': 0.15
        }
        
        metadata = {
            'risk_reward_ratio': 2.0,
            'execution_style': 'aggressive',
            'ofi_value': ofi,
            'sma_distance': (current_price - sma_20) / sma_20
        }
        
        signal = self.create_signal(
            instrument=instrument,
            horizon=horizon,
            direction=direction,
            confidence=confidence,
            entry_price=current_price,
            stop_distance_points=stop_distance,
            target_profile=target_profile,
            regime_sensitivity=regime_sensitivity,
            quality_metrics=quality_metrics,
            expected_half_life_seconds=3600,
            ttl_milliseconds=300000,
            metadata=metadata
        )
        
        return signal


class TradingEngine:
    """Motor de trading con position sizing integrado."""
    
    def __init__(self):
        # Inicializar PML con configuración de capital
        self.pml = PortfolioManagerLayer(
            total_capital=TOTAL_CAPITAL,
            family_allocations=FAMILY_ALLOCATIONS,
            strategy_families=STRATEGY_FAMILIES
        )
        
        self.strategies: List[StrategyAdapter] = [
            ExampleMomentumStrategy(),
        ]
        
        self.positions: Dict[str, Dict] = {}
        self.instruments = ['EURUSD.pro', 'GBPUSD.pro', 'XAUUSD.pro']
        self.decision_tick_ms = 200
        
        logger.info(
            f"TradingEngine inicializado: capital=${TOTAL_CAPITAL:,.2f}, "
            f"{len(self.strategies)} estrategias"
        )
    
    def run_tick(self):
        """Ejecuta un tick del motor."""
        logger.info("=" * 70)
        logger.info("MOTOR_TICK_START")
        
        data_by_instrument = self._fetch_market_data()
        features_by_instrument = self._calculate_features(data_by_instrument)
        self._evaluate_strategies(data_by_instrument, features_by_instrument)
        
        result = self.pml.process_decision_tick(
            data_by_instrument=data_by_instrument,
            features_by_instrument=features_by_instrument
        )
        
        self._execute_decisions(result['executions'])
        self._manage_positions(data_by_instrument)
        self._log_stats(result['stats'])
        
        logger.info("MOTOR_TICK_END")
    
    def _fetch_market_data(self) -> Dict[str, pd.DataFrame]:
        """Obtiene datos de mercado simulados."""
        data_by_instrument = {}
        
        for instrument in self.instruments:
            n_bars = 100
            dates = pd.date_range(end=datetime.now(), periods=n_bars, freq='1min')
            
            base_price = 1.1000 if 'USD' in instrument else 2400.0
            returns = np.random.randn(n_bars) * 0.0001
            prices = base_price * (1 + returns).cumprod()
            
            df = pd.DataFrame({
                'timestamp': dates,
                'open': prices,
                'high': prices * (1 + abs(np.random.randn(n_bars) * 0.0001)),
                'low': prices * (1 - abs(np.random.randn(n_bars) * 0.0001)),
                'close': prices,
                'volume': np.random.randint(100, 1000, n_bars)
            })
            
            df.attrs['symbol'] = instrument
            data_by_instrument[instrument] = df
        
        return data_by_instrument
    
    def _calculate_features(self, data_by_instrument: Dict[str, pd.DataFrame]) -> Dict[str, Dict]:
        """Calcula features con hash de datos."""
        import hashlib
        
        features_by_instrument = {}
        
        for instrument, data in data_by_instrument.items():
            close = data['close']
            
            def _hash_df(df):
                try:
                    arr = df[['open', 'high', 'low', 'close', 'volume']].tail(200).to_numpy()
                    return hashlib.sha1(arr.tobytes()).hexdigest()[:16]
                except Exception:
                    return None
            
            features = {
                'ofi': np.random.randn(),
                'vpin': np.random.uniform(0.3, 0.7),
                'spread_bp': 2.0 if 'USD' in instrument else 10.0,
                'median_spread_bp': 2.0 if 'USD' in instrument else 10.0,
                'vol_ratio': np.random.uniform(0.8, 1.5),
                'vol_of_vol': np.random.uniform(0.5, 1.2),
                'data_quality': True,
                'bid': close.iloc[-1] - 0.0001,
                'ask': close.iloc[-1] + 0.0001,
                'data_slice_id': _hash_df(data)
            }
            
            features_by_instrument[instrument] = features
        
        return features_by_instrument
    
    def _evaluate_strategies(self, data_by_instrument: Dict, features_by_instrument: Dict):
        """Invoca estrategias."""
        total_signals = 0
        
        for strategy in self.strategies:
            for instrument in self.instruments:
                data = data_by_instrument[instrument]
                features = features_by_instrument[instrument]
                
                for horizon in ['intraday', 'swing']:
                    try:
                        signal = strategy.evaluate(data, features, instrument, horizon)
                        
                        if signal is not None:
                            if strategy.publish_signal(signal):
                                total_signals += 1
                    
                    except Exception as e:
                        logger.error(f"Strategy error: {strategy.strategy_id} {instrument}/{horizon}: {e}")
        
        logger.info(f"Strategies evaluated: {total_signals} señales")
    
    def _execute_decisions(self, executions: List[Dict]):
        """
        Ejecuta señales con sizing calculado.
        
        NUEVO: Usa position_size para calcular tamaño de lote real
        y reserva capital en Budget Manager.
        """
        for execution in executions:
            signal = execution['signal']
            position_size = execution['position_size']
            family = execution['family']
            
            position_key = f"{signal.instrument}_{signal.horizon}"
            
            if position_key in self.positions:
                logger.warning(f"EXECUTION_SKIP: {position_key} ya tiene posición")
                continue
            
            # Calcular tamaño de lote real basado en capital y stop
            lot_size = self._calculate_lot_size(
                signal.instrument,
                position_size.capital_amount,
                signal.stop_distance_points
            )
            
            # Reservar capital en Budget Manager
            position_id = f"{position_key}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            if not self.pml.budget_manager.reserve_capital(
                position_id=position_id,
                family=family,
                amount=position_size.capital_amount
            ):
                logger.warning(
                    f"EXECUTION_SKIP: {position_key} no pudo reservar capital "
                    f"(familia={family}, amount=${position_size.capital_amount:,.2f})"
                )
                continue
            
            execution_price = signal.entry_price
            
            self.positions[position_key] = {
                'position_id': position_id,
                'signal': signal,
                'entry_price': execution_price,
                'entry_time': datetime.now(),
                'direction': signal.direction,
                'lot_size': lot_size,
                'capital_at_risk': position_size.capital_amount,
                'stop_price': execution_price - signal.direction * signal.stop_distance_points,
                'target_prices': {
                    name: execution_price + signal.direction * signal.stop_distance_points * ratio
                    for name, ratio in signal.target_profile.items()
                },
                'regime': 'trend',
                'family': family
            }
            
            logger.info(
                f"EXECUTION: {signal.strategy_id} → {signal.instrument} {signal.direction:+d} "
                f"@ {execution_price:.5f} size={lot_size:.2f} lots "
                f"capital=${position_size.capital_amount:,.2f} ({position_size.capital_fraction:.2%})"
            )
    
    def _calculate_lot_size(self, instrument: str, capital_at_risk: float, 
                           stop_distance_points: float) -> float:
        """
        Calcula tamaño de lote real basado en capital y stop.
        
        Args:
            instrument: Instrumento a tradear
            capital_at_risk: Capital absoluto a arriesgar
            stop_distance_points: Distancia al stop en points
            
        Returns:
            Tamaño en lotes standard
        """
        # Valores por point para diferentes instrumentos (simplificado)
        # En producción, leer de instrument_specs.json
        value_per_point = {
            'EURUSD.pro': 10.0,  # $10 por pip en lote standard
            'GBPUSD.pro': 10.0,
            'XAUUSD.pro': 1.0    # $1 por point en oro
        }
        
        pip_value = value_per_point.get(instrument, 10.0)
        
        # Calcular lotes necesarios
        # capital_at_risk = lot_size * stop_distance_points * pip_value
        # lot_size = capital_at_risk / (stop_distance_points * pip_value)
        
        if stop_distance_points == 0:
            return 0.01  # Mínimo
        
        lot_size = capital_at_risk / (stop_distance_points * pip_value)
        
        # Redondear a 0.01 lotes
        lot_size = round(lot_size, 2)
        
        # Aplicar límites min/max
        lot_size = max(0.01, min(lot_size, 100.0))
        
        return lot_size
    
    def _manage_positions(self, data_by_instrument: Dict):
        """Gestiona posiciones abiertas."""
        closed_positions = []
        
        for position_key, position in list(self.positions.items()):
            instrument = position['signal'].instrument
            current_data = data_by_instrument.get(instrument)
            
            if current_data is None:
                continue
            
            current_price = current_data['close'].iloc[-1]
            
            # Check stop
            if position['direction'] == 1:
                if current_price <= position['stop_price']:
                    pnl_r = -1.0
                    self._close_position(position_key, current_price, pnl_r, "STOP")
                    closed_positions.append(position_key)
                    continue
            else:
                if current_price >= position['stop_price']:
                    pnl_r = -1.0
                    self._close_position(position_key, current_price, pnl_r, "STOP")
                    closed_positions.append(position_key)
                    continue
            
            # Check target
            primary_target = position['target_prices'].get('primary')
            
            if primary_target:
                if position['direction'] == 1 and current_price >= primary_target:
                    pnl_r = 2.0
                    self._close_position(position_key, current_price, pnl_r, "TARGET")
                    closed_positions.append(position_key)
                elif position['direction'] == -1 and current_price <= primary_target:
                    pnl_r = 2.0
                    self._close_position(position_key, current_price, pnl_r, "TARGET")
                    closed_positions.append(position_key)
        
        for key in closed_positions:
            del self.positions[key]
    
    def _close_position(self, position_key: str, exit_price: float, pnl_r: float, reason: str):
        """
        Cierra posición y libera capital.
        
        NUEVO: Libera capital del Budget Manager.
        """
        position = self.positions[position_key]
        signal = position['signal']
        position_id = position['position_id']
        
        # Liberar capital en Budget Manager
        self.pml.budget_manager.release_capital(position_id)
        
        # Reportar outcome al PML
        self.pml.record_signal_outcome(
            strategy_id=signal.strategy_id,
            pnl_r=pnl_r,
            horizon=signal.horizon,
            regime=position['regime']
        )
        
        logger.info(
            f"POSITION_CLOSED: {position_key} @ {exit_price:.5f} "
            f"pnl={pnl_r:.2f}R ({pnl_r * position['capital_at_risk']:+,.2f} USD) "
            f"reason={reason}"
        )
    
    def _log_stats(self, stats: Dict):
        """Log de estadísticas."""
        budget_util = stats.get('budget_utilization', {}).get('portfolio', {})
        
        logger.info(
            f"STATS: decisions={stats['total_decisions']}, "
            f"executions={stats['executions']}, "
            f"silences={stats['silences']}, "
            f"open_positions={len(self.positions)}, "
            f"capital_used=${budget_util.get('total_committed', 0):,.2f} "
            f"({budget_util.get('utilization_pct', 0):.1f}%)"
        )


def main():
    """Ejecuta el motor."""
    
    logger.info("=" * 70)
    logger.info("  TRADING SYSTEM - MOTOR CON POSITION SIZING")
    logger.info("=" * 70)
    logger.info("")
    logger.info(f"Inicializando con capital de ${TOTAL_CAPITAL:,.2f}...")
    
    engine = TradingEngine()
    
    logger.info("Ejecutando 5 ticks de ejemplo...")
    logger.info("")
    
    for i in range(5):
        logger.info(f"\nTICK {i+1}/5")
        engine.run_tick()
        time.sleep(0.5)
    
    logger.info("\nActualizando correlaciones...")
    engine.pml.update_correlations()
    
    logger.info("Exportando ledger...")
    engine.pml.export_ledger("output/decision_ledger.json")
    
    logger.info("\n" + "=" * 70)
    logger.info("ESTADÍSTICAS FINALES")
    logger.info("=" * 70)
    
    stats = engine.pml.get_aggregate_stats()
    
    logger.info(f"Total ticks: {stats['total_ticks']}")
    logger.info(f"Total ejecuciones: {stats['total_executions']}")
    logger.info(f"Tasa de ejecución: {stats['execution_rate']:.1%}")
    logger.info("")
    
    # Budget Manager stats
    budget_stats = stats['budget_manager']
    logger.info("Budget Manager:")
    logger.info(f"  Reservas totales: {budget_stats['total_reservations']}")
    logger.info(f"  Liberaciones totales: {budget_stats['total_releases']}")
    logger.info(f"  Capital pico usado: ${budget_stats['peak_capital_used']:,.2f}")
    logger.info("")
    
    # Utilización por familia
    utilization = budget_stats['current_utilization']
    logger.info("Utilización por familia:")
    for family, util in utilization.items():
        if family != 'portfolio':
            logger.info(
                f"  {family}: ${util['committed']:,.2f} / ${util['total_budget']:,.2f} "
                f"({util['utilization_pct']:.1f}%)"
            )
    
    logger.info("")
    logger.info("Conflict Arbiter:")
    logger.info(f"  Ejecuciones: {stats['arbiter']['executions']}")
    logger.info(f"  Silencios: {stats['arbiter']['silences']}")
    logger.info(f"  Rechazos EV: {stats['arbiter']['ev_rejections']}")
    logger.info("")
    logger.info("=" * 70)
    logger.info("Motor completado exitosamente")
    logger.info("=" * 70)


if __name__ == "__main__":
    main()
