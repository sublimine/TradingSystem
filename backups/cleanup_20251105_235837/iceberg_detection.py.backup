"""
Iceberg Detection Strategy.

Identifies hidden large orders and trades their revelation.
Operates in degraded mode without L2 data.
"""

import pandas as pd
import numpy as np
from typing import Dict, Optional, List
from datetime import datetime
import logging

from strategies.strategy_base import StrategyBase, Signal
from features.orderbook_l2 import (
    parse_l2_snapshot,
    detect_iceberg_signature,
    OrderBookSnapshot
)

logger = logging.getLogger(__name__)

class IcebergDetection(StrategyBase):
    """Iceberg detection strategy with degraded mode support."""
    
    def __init__(self, params: Dict):
        super().__init__(params)
        
        self.mode = params.get('mode', 'degraded')
        self.volume_advancement_ratio_threshold = params.get('volume_advancement_ratio_threshold', 15.0)
        self.stall_duration_bars = params.get('stall_duration_bars', 5)
        self.replenishment_detection = params.get('replenishment_detection', True)
        self.stop_loss_behind_level_atr = params.get('stop_loss_behind_level_atr', 1.0)
        self.take_profit_r_multiple = params.get('take_profit_r_multiple', 2.5)
        
        self.l2_available = False
        self.l2_snapshots: List[OrderBookSnapshot] = []
        
        if self.mode == 'degraded':
            logger.warning("Iceberg Detection initialized in DEGRADED MODE")
        else:
            logger.info(f"Iceberg Detection initialized: mode={self.mode}")
    
    def _check_l2_availability(self, features: Dict) -> bool:
        """Check if L2 data is available."""
        try:
            l2_data = features.get('l2_data')
            
            if l2_data is not None:
                snapshot = parse_l2_snapshot(l2_data)
                if snapshot is not None:
                    self.l2_snapshots.append(snapshot)
                    self.l2_snapshots = self.l2_snapshots[-100:]
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"L2 availability check failed: {str(e)}")
            return False
    
    def evaluate(self, data: pd.DataFrame, features: Dict) -> Optional[Signal]:
        """Evaluate iceberg detection conditions."""
        try:
            if len(data) < 50:
                logger.debug(f"Insufficient data: {len(data)} bars")
                return None
            
            atr = features.get('atr')
            if atr is None or np.isnan(atr) or atr <= 0:
                logger.warning(f"Invalid ATR: {atr}")
                return None
            
            self.l2_available = self._check_l2_availability(features)
            
            if not self.l2_available and self.mode != 'degraded':
                logger.warning("L2 data not available - switching to DEGRADED MODE")
                self.mode = 'degraded'
            
            iceberg = detect_iceberg_signature(
                data.tail(20),
                self.l2_snapshots if self.l2_available else None,
                self.stall_duration_bars,
                self.volume_advancement_ratio_threshold
            )
            
            if iceberg:
                logger.info(f"Iceberg detected in {iceberg['mode']} mode: "
                          f"confidence={iceberg['confidence']}")
                
                if iceberg['mode'] == 'DEGRADED' and iceberg['confidence'] == 'LOW':
                    logger.debug("Skipping low confidence iceberg in degraded mode")
                    return None
                
                signal = self._create_iceberg_signal(iceberg, data, atr, features)
                return signal
            
            return None
            
        except Exception as e:
            logger.error(f"Iceberg evaluation failed: {str(e)}", exc_info=True)
            return None
    
    def _create_iceberg_signal(self, iceberg: Dict, data: pd.DataFrame,
                              atr: float, features: Dict) -> Optional[Signal]:
        """Create signal for iceberg trade."""
        try:
            current_price = data.iloc[-1]['close']
            iceberg_level = iceberg.get('price_level', current_price)
            
            if iceberg.get('side') == 'BID' or current_price > iceberg_level:
                direction = "LONG"
                entry_price = current_price
                stop_loss = iceberg_level - (self.stop_loss_behind_level_atr * atr)
                risk = entry_price - stop_loss
                take_profit = entry_price + (risk * self.take_profit_r_multiple)
                
            else:
                direction = "SHORT"
                entry_price = current_price
                stop_loss = iceberg_level + (self.stop_loss_behind_level_atr * atr)
                risk = stop_loss - entry_price
                take_profit = entry_price - (risk * self.take_profit_r_multiple)
            
            actual_risk = abs(entry_price - stop_loss)
            actual_reward = abs(take_profit - entry_price)
            rr_ratio = actual_reward / actual_risk if actual_risk > 0 else 0
            
            if rr_ratio < 2.0:
                logger.debug(f"Iceberg signal rejected: R:R {rr_ratio:.2f} < 2.0")
                return None
            
            if iceberg['confidence'] == 'HIGH':
                sizing_level = 3
            elif iceberg['confidence'] == 'MEDIUM':
                sizing_level = 2
            else:
                sizing_level = 1
            
            signal = Signal(
                timestamp=datetime.now(),
                symbol=data.attrs.get('symbol', 'UNKNOWN'),
                strategy_name="Iceberg_Detection",
                direction=direction,
                entry_price=entry_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                sizing_level=sizing_level,
                metadata={
                    'detection_mode': iceberg['mode'],
                    'confidence': iceberg['confidence'],
                    'iceberg_level': float(iceberg_level),
                    'iceberg_side': iceberg.get('side', 'UNKNOWN'),
                    'volume_price_ratio': iceberg.get('volume_price_ratio', 0),
                    'risk_reward_ratio': float(rr_ratio),
                    'l2_available': self.l2_available,
                    'rationale': f"Iceberg detected at {iceberg_level:.5f} in {iceberg['mode']} mode "
                               f"with {iceberg['confidence']} confidence."
                }
            )
            
            logger.info(f"Iceberg Signal: {direction} @ {entry_price:.5f}, "
                       f"mode={iceberg['mode']}, R:R={rr_ratio:.2f}")
            
            return signal
            
        except Exception as e:
            logger.error(f"Iceberg signal creation failed: {str(e)}", exc_info=True)
            return None
