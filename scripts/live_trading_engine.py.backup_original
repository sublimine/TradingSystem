"""
Live Trading Engine - Real-time Execution
Monitors markets continuously and executes trades when strategies generate signals
"""

import sys
sys.path.insert(0, 'C:/TradingSystem')
sys.path.insert(0, 'C:/TradingSystem/src')

import MetaTrader5 as mt5
import psycopg2
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import time
import importlib
import inspect
import logging

from features.technical_indicators import calculate_atr, calculate_rsi, identify_swing_points
from features.order_flow import VPINCalculator, calculate_signed_volume
from features.statistical_models import calculate_realized_volatility

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(message)s',
    handlers=[
        logging.FileHandler('C:/TradingSystem/logs/live_trading.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

DB_CONFIG = {
    'host': 'localhost',
    'port': 5432,
    'database': 'trading_system',
    'user': 'trading_user',
    'password': 'abc'
}

STRATEGY_MODULES = [
    'minimal_test'  # Solo estrategia de prueba
]

SYMBOLS = [
    'EURUSD.pro', 'GBPUSD.pro', 'USDJPY.pro', 'AUDUSD.pro',
    'USDCAD.pro', 'USDCHF.pro', 'NZDUSD.pro', 'EURGBP.pro',
    'XAUUSD.pro', 'BTCUSD', 'ETHUSD'
]

SCAN_INTERVAL_SECONDS = 60
LOOKBACK_BARS = 500


class LiveTradingEngine:
    """Motor de trading en vivo que ejecuta las 9 estrategias en tiempo real."""
    
    def __init__(self):
        self.strategies = []
        self.stats = {}
        self.running = False
        self.scan_count = 0
        self.vpin_calculators = {symbol: VPINCalculator() for symbol in SYMBOLS}
        
        # CAMBIO 1: Tracking de posiciones para anti-duplicados
        self.open_positions = {}  # {symbol: {'direction': 'LONG/SHORT', 'time': datetime}}
        self.position_cooldown = 180  # 3 minutos cooldown
        
    def initialize_mt5(self) -> bool:
        """Inicializa conexión con MetaTrader 5."""
        if not mt5.initialize():
            logger.error("ERROR: No se pudo inicializar MT5")
            return False
        
        account = mt5.account_info()
        if account is None:
            logger.error("ERROR: No hay cuenta conectada")
            mt5.shutdown()
            return False
        
        logger.info(f"OK Conectado a {account.server}")
        logger.info(f"OK Cuenta: {account.login}")
        logger.info(f"OK Balance: ${account.balance:,.2f}")
        logger.info(f"OK Equity: ${account.equity:,.2f}\n")
        
        return True
    
    def load_strategies(self):
        """Carga las 9 estrategias originales."""
        logger.info("Cargando estrategias...")
        
        for module_name in STRATEGY_MODULES:
            try:
                module = importlib.import_module(f'strategies.{module_name}')
                classes = [(n, o) for n, o in inspect.getmembers(module, inspect.isclass)
                          if o.__module__ == f'strategies.{module_name}']
                
                if classes:
                    class_name, strategy_class = classes[0]
                    config = {'enabled': True, 'symbols': SYMBOLS}
                    instance = strategy_class(config)
                    
                    self.strategies.append({
                        'name': module_name,
                        'instance': instance,
                        'class': class_name
                    })
                    
                    # CAMBIO 2: Agregar campo evaluations
                    self.stats[module_name] = {
                        'scans': 0,
                        'signals': 0,
                        'trades_sent': 0,
                        'last_signal': None,
                        'evaluations': 0
                    }
                    
                    logger.info(f"  OK {module_name}")
                    
            except Exception as e:
                logger.error(f"  ERROR {module_name}: {str(e)[:60]}")
        
        logger.info(f"\nOK {len(self.strategies)} estrategias cargadas\n")
    
    def get_market_data(self, symbol: str, bars: int) -> pd.DataFrame:
        """Obtiene datos de mercado en tiempo real desde MT5."""
        try:
            rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_M1, 0, bars)
            
            if rates is None or len(rates) == 0:
                return pd.DataFrame()
            
            df = pd.DataFrame(rates)
            df['time'] = pd.to_datetime(df['time'], unit='s')
            df['symbol'] = symbol
            df['volume'] = df['tick_volume']
            
            return df
            
        except Exception as e:
            logger.error(f"Error obteniendo datos de {symbol}: {e}")
            return pd.DataFrame()
    
    def calculate_features(self, data: pd.DataFrame, symbol: str) -> dict:
        """Calcula features para evaluación de estrategias."""
        features = {}
        
        if len(data) < 50:
            return features
        
        try:
            if len(data) >= 14:
                atr_series = calculate_atr(data['high'], data['low'], data['close'], 14)
                features['atr'] = float(atr_series.iloc[-1]) if len(atr_series) > 0 else 0
                
                rsi_series = calculate_rsi(data['close'], 14)
                features['rsi'] = float(rsi_series.iloc[-1]) if len(rsi_series) > 0 else 50
            
            swing_highs, swing_lows = identify_swing_points(data['high'], order=5)
            features['swing_high_levels'] = data.loc[swing_highs.tail(20), 'high'].values.tolist()
            features['swing_low_levels'] = data.loc[swing_lows.tail(20), 'low'].values.tolist()
            
            signed_vol = calculate_signed_volume(data['close'], data['volume'])
            features['cumulative_volume_delta'] = float(signed_vol.sum())
            
            for _, row in data.tail(50).iterrows():
                direction = 1 if row['close'] > row['open'] else -1
                self.vpin_calculators[symbol].add_trade(row['volume'], direction)
            
            features['vpin'] = self.vpin_calculators[symbol].get_current_vpin()
            
            returns = data['close'].pct_change().dropna()
            if len(returns) >= 20:
                vol = calculate_realized_volatility(returns.tail(60), window=20)
                recent_vol = vol[-1] if len(vol) > 0 else 0
                avg_vol = np.mean(vol) if len(vol) > 0 else 0
                features['volatility_regime'] = 1 if recent_vol > avg_vol else 0
            else:
                features['volatility_regime'] = 0
            
            buy_vol = data.loc[data['close'] > data['open'], 'volume'].sum()
            sell_vol = data.loc[data['close'] <= data['open'], 'volume'].sum()
            total = buy_vol + sell_vol
            features['order_book_imbalance'] = float((buy_vol - sell_vol) / total) if total > 0 else 0
            features['momentum_quality'] = 0.7
            features['spread'] = float((data['high'] - data['low']).mean())
            
        except Exception as e:
            logger.debug(f"Error calculando features: {e}")
        
        return features
    
    # CAMBIO 3: Nuevos métodos para anti-duplicados
    def can_open_position(self, symbol: str, direction: str) -> bool:
        """Verifica si puede abrir posición (anti-duplicados)."""
        # Verificar posiciones abiertas en MT5
        positions = mt5.positions_get(symbol=symbol)
        
        if positions:
            for pos in positions:
                pos_type = pos.type
                pos_direction = 'LONG' if pos_type == 0 else 'SHORT'
                
                if pos_direction == direction:
                    return False  # Ya hay posición en esta dirección
        
        # Verificar cooldown interno
        key = f"{symbol}_{direction}"
        if key in self.open_positions:
            time_since = (datetime.now() - self.open_positions[key]).total_seconds()
            if time_since < self.position_cooldown:
                return False  # Cooldown activo
        
        return True
    
    def record_position_opened(self, symbol: str, direction: str):
        """Registra que se abrió una posición."""
        key = f"{symbol}_{direction}"
        self.open_positions[key] = datetime.now()
    
    def execute_order(self, signal) -> bool:
        """Ejecuta orden en MT5."""
        try:
            symbol = signal.symbol
            direction = mt5.ORDER_TYPE_BUY if signal.direction == 'LONG' else mt5.ORDER_TYPE_SELL
            
            symbol_info = mt5.symbol_info(symbol)
            if symbol_info is None:
                logger.error(f"ERROR: Simbolo {symbol} no disponible")
                return False
            
            volume = symbol_info.volume_min
            
            tick = mt5.symbol_info_tick(symbol)
            if tick is None:
                logger.error(f"ERROR: No tick para {symbol}")
                return False
            
            price = tick.ask if direction == mt5.ORDER_TYPE_BUY else tick.bid
            
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": volume,
                "type": direction,
                "price": price,
                "sl": signal.stop_loss,
                "tp": signal.take_profit,
                "deviation": 20,
                "magic": 234000,
                "comment": "algo_trade",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_FOK,
            }
            
            result = mt5.order_send(request)
            
            if result is None:
                error = mt5.last_error()
                logger.error(f"ERROR: order_send devolvio None - {error}")
                return False
            
            if result.retcode != mt5.TRADE_RETCODE_DONE:
                logger.error(f"ERROR: Orden rechazada - {result.comment} (retcode: {result.retcode})")
                return False
            
            logger.info(f"OK ORDEN EJECUTADA: {signal.direction} {symbol} @ {price:.5f}")
            logger.info(f"   SL: {signal.stop_loss:.5f} | TP: {signal.take_profit:.5f}")
            logger.info(f"   Ticket: {result.order}")
            
            return True
            
        except Exception as e:
            logger.error(f"ERROR ejecutando orden: {e}")
            return False
    
    def scan_markets(self):
        """Escanea todos los símbolos con todas las estrategias."""
        self.scan_count += 1
        signals_generated = 0
        
        logger.info(f"{'=' * 80}")
        logger.info(f"SCAN #{self.scan_count} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info(f"{'=' * 80}")
        
        for symbol in SYMBOLS:
            data = self.get_market_data(symbol, LOOKBACK_BARS)
            
            if data.empty or len(data) < 100:
                continue
            
            features = self.calculate_features(data, symbol)
            
            if not features:
                continue
            
            current_price = float(data['close'].iloc[-1])
            
            for strategy_info in self.strategies:
                strategy_name = strategy_info['name']
                self.stats[strategy_name]['scans'] += 1
                
                try:
                    signals = strategy_info['instance'].evaluate(data, features)
                    
                    # CAMBIO 4: Contar evaluación
                    self.stats[strategy_name]['evaluations'] += 1
                    
                    if signals:
                        signal_list = signals if isinstance(signals, list) else [signals]
                        
                        for signal in signal_list:
                            if signal is not None and signal.validate():
                                
                                # CAMBIO 5: Filtro anti-duplicados
                                if not self.can_open_position(signal.symbol, signal.direction):
                                    logger.debug(f"Señal rechazada: Ya hay posicion en {signal.symbol} {signal.direction}")
                                    continue
                                
                                signals_generated += 1
                                self.stats[strategy_name]['signals'] += 1
                                self.stats[strategy_name]['last_signal'] = datetime.now()
                                
                                logger.info(f"\nSEÑAL GENERADA:")
                                logger.info(f"  Estrategia: {strategy_name}")
                                logger.info(f"  Simbolo: {symbol}")
                                logger.info(f"  Direccion: {signal.direction}")
                                logger.info(f"  Precio actual: {current_price:.5f}")
                                logger.info(f"  Entry: {signal.entry_price:.5f}")
                                logger.info(f"  Stop Loss: {signal.stop_loss:.5f}")
                                logger.info(f"  Take Profit: {signal.take_profit:.5f}")
                                
                                # CAMBIO 6: Registrar posición después de ejecutar
                                if self.execute_order(signal):
                                    self.stats[strategy_name]['trades_sent'] += 1
                                    self.record_position_opened(signal.symbol, signal.direction)
                
                except Exception as e:
                    logger.error(f"ERROR evaluando {strategy_name}: {e}")
        
        logger.info(f"\nResultados del scan:")
        logger.info(f"  Señales generadas: {signals_generated}")
        logger.info(f"  Proximo scan en {SCAN_INTERVAL_SECONDS} segundos")
        
        if self.scan_count % 10 == 0:
            self.print_statistics()
    
    def print_statistics(self):
        """Imprime estadísticas acumuladas."""
        logger.info(f"\n{'=' * 80}")
        logger.info(f"ESTADISTICAS ACUMULADAS (Scan #{self.scan_count})")
        logger.info(f"{'=' * 80}")
        
        # CAMBIO 7: Mostrar evaluaciones y tasa de conversión
        for strategy_name, stats in sorted(self.stats.items(), key=lambda x: x[1]['signals'], reverse=True):
            evals = stats['evaluations']
            signals = stats['signals']
            conversion = (signals / evals * 100) if evals > 0 else 0
            
            logger.info(f"\n{strategy_name}:")
            logger.info(f"  Evaluaciones: {evals:,}")
            logger.info(f"  Señales: {signals}")
            logger.info(f"  Conversion: {conversion:.2f}%")
            logger.info(f"  Trades enviados: {stats['trades_sent']}")
            
            if stats['last_signal']:
                logger.info(f"  Ultima señal: {stats['last_signal'].strftime('%H:%M:%S')}")
        
        total_signals = sum(s['signals'] for s in self.stats.values())
        total_trades = sum(s['trades_sent'] for s in self.stats.values())
        logger.info(f"\nTOTAL:")
        logger.info(f"  Señales generadas: {total_signals}")
        logger.info(f"  Trades ejecutados: {total_trades}")
        logger.info(f"{'=' * 80}")
    
    def run(self):
        """Loop principal de trading en vivo."""
        logger.info("\n" + "=" * 80)
        logger.info("SISTEMA DE TRADING EN VIVO INICIADO")
        logger.info("=" * 80)
        logger.info(f"Estrategias activas: {len(self.strategies)}")
        logger.info(f"Simbolos monitoreados: {len(SYMBOLS)}")
        logger.info(f"Intervalo de escaneo: {SCAN_INTERVAL_SECONDS} segundos")
        logger.info(f"Cooldown anti-duplicados: {self.position_cooldown} segundos")
        logger.info(f"Modo: DEMO")
        logger.info("=" * 80)
        logger.info("\nSistema operando en tiempo real")
        logger.info("Presione Ctrl+C para detener\n")
        
        self.running = True
        
        try:
            while self.running:
                self.scan_markets()
                time.sleep(SCAN_INTERVAL_SECONDS)
                
        except KeyboardInterrupt:
            logger.info("\n\nDeteniendo sistema...")
            self.print_statistics()
        
        finally:
            mt5.shutdown()
            logger.info("\nOK Sistema detenido correctamente")


def main():
    engine = LiveTradingEngine()
    
    if not engine.initialize_mt5():
        return False
    
    engine.load_strategies()
    engine.run()
    
    return True


if __name__ == "__main__":
    main()



